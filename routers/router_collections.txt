from fastapi import APIRouter, Depends, HTTPException
from psycopg2.extras import RealDictCursor
from datetime import date, timedelta

from database import get_db

router = APIRouter(
    prefix="/collections",
    tags=["Collections"]
)

# ============================================================
# Helpers
# ============================================================
def calcular_bucket_aging(aging_dias: int) -> str:
    if aging_dias <= 0:
        return "CURRENT"
    if 1 <= aging_dias <= 30:
        return "1-30"
    if 31 <= aging_dias <= 60:
        return "31-60"
    if 61 <= aging_dias <= 90:
        return "61-90"
    return "90+"


# ============================================================
# POST /collections/sync
# Sincroniza facturas desde Billing (invoicing)
# ============================================================
@router.post("/sync")
def sync_collections(conn=Depends(get_db)):

    cur = conn.cursor(cursor_factory=RealDictCursor)

    try:
        # ===============================
        # 1️⃣ Traer facturas emitidas
        # ===============================
        cur.execute("""
            SELECT
                i.numero_documento,
                i.codigo_cliente,
                i.nombre_cliente,
                i.tipo_factura,
                i.tipo_documento,
                i.fecha_emision,
                i.moneda,
                i.total,
                i.estado,
                i.num_informe,
                i.buque_contenedor,
                i.operacion,
                i.periodo_operacion,
                i.descripcion_servicio
            FROM invoicing i
        """)
        facturas = cur.fetchall()

        hoy = date.today()
        synced = 0

        # ===============================
        # 2️⃣ Procesar una por una
        # ===============================
        for f in facturas:

            numero = f["numero_documento"]
            codigo_cliente = f["codigo_cliente"]

            # -------------------------------
            # Días de crédito
            # -------------------------------
            cur.execute("""
                SELECT termino_pago
                FROM cliente_credito
                WHERE codigo_cliente = %s
                LIMIT 1
            """, (codigo_cliente,))
            row_credito = cur.fetchone()

            dias_credito = row_credito["termino_pago"] if row_credito else 0
            dias_credito = dias_credito or 0

            # -------------------------------
            # Fechas
            # -------------------------------
            fecha_emision = f["fecha_emision"]
            fecha_vencimiento = fecha_emision + timedelta(days=dias_credito)

            aging_dias = (hoy - fecha_vencimiento).days
            bucket = calcular_bucket_aging(aging_dias)

            # -------------------------------
            # Estado inicial
            # -------------------------------
            estado_factura = (
                "PAGADA" if (f.get("estado") == "PAGADA")
                else "PENDIENTE_PAGO"
            )

            # -------------------------------
            # Upsert en collections
            # -------------------------------
            cur.execute("""
                INSERT INTO collections (
                    numero_documento,
                    codigo_cliente,
                    nombre_cliente,
                    tipo_factura,
                    tipo_documento,
                    fecha_emision,
                    fecha_vencimiento,
                    moneda,
                    total,
                    dias_credito,
                    aging_dias,
                    bucket_aging,
                    num_informe,
                    buque_contenedor,
                    operacion,
                    periodo_operacion,
                    descripcion_servicio,
                    estado_factura,
                    disputada
                ) VALUES (
                    %(numero_documento)s,
                    %(codigo_cliente)s,
                    %(nombre_cliente)s,
                    %(tipo_factura)s,
                    %(tipo_documento)s,
                    %(fecha_emision)s,
                    %(fecha_vencimiento)s,
                    %(moneda)s,
                    %(total)s,
                    %(dias_credito)s,
                    %(aging_dias)s,
                    %(bucket_aging)s,
                    %(num_informe)s,
                    %(buque_contenedor)s,
                    %(operacion)s,
                    %(periodo_operacion)s,
                    %(descripcion_servicio)s,
                    %(estado_factura)s,
                    FALSE
                )
                ON CONFLICT (numero_documento)
                DO UPDATE SET
                    fecha_vencimiento = EXCLUDED.fecha_vencimiento,
                    dias_credito = EXCLUDED.dias_credito,
                    aging_dias = EXCLUDED.aging_dias,
                    bucket_aging = EXCLUDED.bucket_aging,
                    estado_factura = EXCLUDED.estado_factura
            """, {
                "numero_documento": numero,
                "codigo_cliente": f["codigo_cliente"],
                "nombre_cliente": f["nombre_cliente"],
                "tipo_factura": f["tipo_factura"],
                "tipo_documento": f["tipo_documento"],
                "fecha_emision": f["fecha_emision"],
                "fecha_vencimiento": fecha_vencimiento,
                "moneda": f["moneda"],
                "total": f["total"],
                "dias_credito": dias_credito,
                "aging_dias": aging_dias,
                "bucket_aging": bucket,
                "num_informe": f.get("num_informe"),
                "buque_contenedor": f.get("buque_contenedor"),
                "operacion": f.get("operacion"),
                "periodo_operacion": f.get("periodo_operacion"),
                "descripcion_servicio": f.get("descripcion_servicio"),
                "estado_factura": estado_factura
            })

            synced += 1

        conn.commit()

        return {
            "status": "ok",
            "synced": synced
        }

    except Exception as e:
        conn.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Error sincronizando collections: {str(e)}"
        )

    finally:
        cur.close()
